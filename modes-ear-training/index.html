<html>
<head>
  <style>
    * {
      box-sizing: border-box;
      font-family: "Lucida Grande", sans-serif;
    }

    #answer {
      width: 400px;
    }

    #ask-button {
      margin: 10px;
    }

    #replay-button {
      margin: 10px;
    }

    #stop-button {
      margin: 10px;
    }

    .answer-correct {
      background: lightgreen;
    }

    .answer-incorrect {
      background: lightcoral;
    }

    .scale {
      margin: 10px;
      width: 220px;
      display: inline-block;
    }

    .scale-name {
      width: 220px;
    }

    .modes {
      width: 280px;
      margin-top: 10px;
    }

    .mode-answer-button {
      width: 200px;
      text-align: left;
      margin: 4px;
    }

    .mode-play-button {
      display: inline-block;
    }

    .visible {
      visibility: visible;
    }

    .hidden {
      visibility: hidden;
    }

  </style>

<script type="module">

import {FretboardBuilder} from "./fretboard/fretboard.js";
import {Scale, scales, scaleNames, scaleModeNames} from "./music.js";
import WebAudioFontPlayer from "https://kairuz.github.io/webaudiofont/npm/dist/player.js";

const audioContext = new AudioContext();


window.addEventListener('load', () => {

  const webAudioFontPlayer = new WebAudioFontPlayer();

  const webAudioFontPresetPath = 'https://surikov.github.io/webaudiofontdata/sound/0253_Acoustic_Guitar_sf2_file.js';
  const webAudioFontPresetVarName = '_tone_0253_Acoustic_Guitar_sf2_file';

  const webAudioLazyLoader = (() => {
    const buildPromise = () => {
      return new Promise((resolve) => {
        webAudioFontPlayer.loader.startLoad(audioContext, webAudioFontPresetPath, webAudioFontPresetVarName);
        webAudioFontPlayer.loader.waitLoad(() => {
          console.log('WAITED LOAD - RESOLVING');
          resolve();
        });
      });
    };

    let promise = null;

    return {
      get: () => {
        if (promise === null) {
          promise = buildPromise();
        }
        return promise;
      }
    }
  })();

  let expectedScaleNameIndex = null;
  let expectedScaleName = null;
  let expectedModeNameIndex = null;
  let expectedModeName = null;

  const playingNodes = (() => {
    let playingNodesSeq = 0;
    const playingNodesMap = new Map();
    return {
      add: (node) => {
        const playingNodeId = playingNodesSeq++;
        playingNodesMap.set(playingNodeId, node);
        node.addEventListener('ended', () => {
          playingNodesMap.delete(playingNodeId);

          if (playingNodesMap.size === 0) {
            stopButton.setAttribute('disabled', 'disabled');
            replayButton.removeAttribute('disabled');
            playingNodesSeq = 0;
          }
        });
      },
      stop: () => {
        playingNodesMap.forEach((playingNode) => playingNode.stop());
      }
    };
  })();

  const loadAudio = () => {
    return new Promise((resolve, reject) => {
      // "suspended" | "running" | "closed";
      console.log('audioContext.state ' + audioContext.state);
      switch (audioContext.state) {
        case 'suspended': {
          audioContext
              .resume()
              .then(resolve);
          return;
        }
        case 'running': {
          resolve();
          return;
        }
        default: {
          reject('invalid audioContext state');
          return;
        }
      }
    }).then(() => webAudioLazyLoader.get());
  };

  const ask = () => {
    loadAudio().then(() => {

      scaleIndexIncludesForRound.clear();
      scaleIndexIncludes.forEach((scaleIndexInclude) => scaleIndexIncludesForRound.add(scaleIndexInclude));

      const scaleIndexIncludesArr = Array.from(scaleIndexIncludes.values());
      const scaleIndexExcludesArr = Array.from(scales.keys()).filter((i) => !scaleIndexIncludes.has(i));

      expectedScaleNameIndex = scaleIndexIncludesArr[Math.trunc(Math.random() * scaleIndexIncludesArr.length)];
      expectedScaleName = scaleNames[expectedScaleNameIndex];
      const expectedScaleModeNames = scaleModeNames[expectedScaleNameIndex];
      expectedModeNameIndex = Math.trunc(Math.random() * expectedScaleModeNames.length);
      expectedModeName = expectedScaleModeNames[expectedModeNameIndex];
      console.log(`(CHEAT...) expected ${expectedScaleName} - ${expectedModeName}`);
      allModeAnswerButtons.forEach((modeAnswerButton) => modeAnswerButton.removeAttribute('disabled'));
      allModePlayButtons.forEach((modePlayButton) => modePlayButton.setAttribute('disabled', 'disabled'));

      scaleIndexIncludesArr
          .map((scaleIndexInclude) => scaleUis[scaleIndexInclude])
          .forEach((scaleUi) => scaleUi.getModeAnswerButtons().forEach((modeButton) => modeButton.removeAttribute('disabled')));
      scaleIndexExcludesArr
          .map((scaleIndexExclude) => scaleUis[scaleIndexExclude])
          .forEach((scaleUi) => scaleUi.getModeAnswerButtons().forEach((modeButton) => modeButton.setAttribute('disabled' , 'disabled')));

      const expectedScale = scales[expectedScaleNameIndex];
      fretboardDiv.classList.remove('visible');
      fretboardDiv.classList.add('hidden');
      fretboard.selectScale(Scale(`C - ${expectedScaleName} - ${expectedModeName}`, expectedScale.toModeFlags(expectedModeNameIndex + 1)));

      stop();
      playExpectedScaleMode();

      answerDiv.innerHTML = '&nbsp;';
      answerDiv.classList.remove('answer-incorrect');
      answerDiv.classList.remove('answer-correct');
    });
  };

  const stop = () => {
    playingNodes.stop();
  };

  const playExpectedScaleMode = () => {
    play(expectedScaleNameIndex, expectedModeNameIndex);
  };

  const play = (scaleNameIndex, modeNameIndex) => {
    const playOctave = (delayFactor, playOctaves, sustainFactor = delayFactor * 1.4, octave = 4) => {
      const scale = scales[scaleNameIndex];
      const flags = scale.toModeFlags(modeNameIndex + 1);

      for (let i = 0; i <= flags.length * playOctaves; i++) {
        const flag = flags[i % flags.length];
        if (flag === true) {

          const node = webAudioFontPlayer.queueWaveTable(
              audioContext, audioContext.destination, window[webAudioFontPresetVarName],
              audioContext.currentTime + delayAcc, (12 * octave) + i, sustainFactor);

          playingNodes.add(node.audioBufferSourceNode);

          nodePromises.push(new Promise((resolve) => {
            node.audioBufferSourceNode.addEventListener('ended', resolve);
          }));
          delayAcc += delayFactor;
        }
      }

      for (let i = (flags.length * playOctaves) - 1; i >= 0; i--) {
        const flag = flags[i % flags.length];
        if (flag === true) {

          const node = webAudioFontPlayer.queueWaveTable(
              audioContext, audioContext.destination, window[webAudioFontPresetVarName],
              audioContext.currentTime + delayAcc, (12 * 4) + i, i === 0 ? sustainFactor * 1.6 : sustainFactor);

          playingNodes.add(node.audioBufferSourceNode);

          nodePromises.push(new Promise((resolve) => {
            node.audioBufferSourceNode.addEventListener('ended', resolve);
          }));
          delayAcc += delayFactor;
        }
      }
    };

    replayButton.setAttribute('disabled', 'disabled');
    stopButton.removeAttribute('disabled');

    const nodePromises = [];
    let delayAcc = 0;

    playOctave(0.4, 1);
    playOctave(0.25, 1);
    playOctave(0.18, 1);
    playOctave(0.4, 2);
    playOctave(0.25, 2);
    playOctave(0.18, 2);

    return Promise.all(nodePromises);
  };

  const askAnswerDiv = document.createElement('div');

  const answerDiv = document.createElement('div');
  answerDiv.setAttribute('id', 'answer');
  answerDiv.innerHTML = '&nbsp;';
  askAnswerDiv.appendChild(answerDiv);

  const askButton = document.createElement('button');
  askButton.setAttribute('id', 'ask-button');
  askButton.textContent = 'next';
  askAnswerDiv.appendChild(askButton);
  askButton.addEventListener('click', () => {
    if (scaleIndexIncludes.size > 0) {
      ask();
    }
  });

  const replayButton = document.createElement('button');
  replayButton.setAttribute('id', 'replay-button');
  replayButton.textContent = 'replay';
  askAnswerDiv.appendChild(replayButton);
  replayButton.setAttribute('disabled', 'disabled');
  replayButton.addEventListener('click', () => {
    replayButton.setAttribute('disabled', 'disabled');
    playExpectedScaleMode();
  });

  const stopButton = document.createElement('button');
  stopButton.setAttribute('id', 'stop-button');
  stopButton.textContent = 'stop';
  askAnswerDiv.appendChild(stopButton);
  stopButton.setAttribute('disabled', 'disabled');
  stopButton.addEventListener('click', () => {
    stop();
  });

  const appDiv = document.getElementById('app');

  appDiv.appendChild(askAnswerDiv);

  const answer = (scaleName, modeName) => {
    const correct = (scaleName === expectedScaleName && modeName === expectedModeName);

    answerDiv.innerHTML = `${expectedScaleName} - ${expectedModeName}`;

    if (correct) {
      answerDiv.classList.add('answer-correct');
    }
    else {
      answerDiv.classList.add('answer-incorrect');
    }

    fretboardDiv.classList.remove('hidden');
    fretboardDiv.classList.add('visible');

    allModeAnswerButtons.forEach((modeAnswerButton) => modeAnswerButton.setAttribute('disabled', 'disabled'));
    allModePlayButtons.forEach((modePlayButton) => modePlayButton.removeAttribute('disabled'));
    expectedScaleName = null;
    expectedModeName = null;
  };

  const scaleIndexIncludes = new Set();
  const scaleIndexIncludesForRound = new Set();

  const ScaleUi = (scaleIndex, scale, scaleName, modeNames, include) => {
    const div = document.createElement('div');
    div.classList.add('scale');

    const scaleHeaderDiv = document.createElement('div');
    scaleHeaderDiv.classList.add('scale-name');
    scaleHeaderDiv.textContent = scaleName;

    const includeCheckbox = document.createElement('input');
    includeCheckbox.setAttribute('type', 'checkbox');

    scaleHeaderDiv.appendChild(includeCheckbox);
    if (include === true) {
      includeCheckbox.checked = include;
      scaleIndexIncludes.add(scaleIndex);
    }
    includeCheckbox.addEventListener('click', () => {
      if (includeCheckbox.checked) {
        scaleIndexIncludes.add(scaleIndex);
      }
      else {
        scaleIndexIncludes.delete(scaleIndex);
      }
    });

    div.appendChild(scaleHeaderDiv);

    const modesDiv = document.createElement('div');
    modesDiv.classList.add('modes');
    div.appendChild(modesDiv);

    const modeAnswerButtons = Array.from(Array(scale.getNoOfNotes()).keys()).map((i) => {
      const modeName = modeNames[i];
      const modeDiv = document.createElement('div');
      modeDiv.classList.add('mode');
      modesDiv.appendChild(modeDiv);
      const modeAnswerButton = document.createElement('button');
      modeAnswerButton.classList.add('mode-answer-button');
      modeAnswerButton.textContent = modeName;
      modeDiv.appendChild(modeAnswerButton);
      modeAnswerButton.addEventListener('click', () => {
        if (scaleIndexIncludesForRound.has(scaleIndex)) {
          if (expectedScaleName !== null && expectedModeName !== null) {
            answer(scaleName, modeName);
          }
        }
      });
      const modePlayButton = document.createElement('button');
      modePlayButton.classList.add('mode-play-button');

      modePlayButton.textContent = String.fromCodePoint(128266);
      modeDiv.appendChild(modePlayButton);
      modePlayButton.addEventListener('click', () => {
        loadAudio().then(() => {
          stop();
          play(scaleIndex, i);
        });
      });
      modeAnswerButton.setAttribute('disabled', 'disabled');

      allModeAnswerButtons.push(modeAnswerButton);
      allModePlayButtons.push(modePlayButton);

      return modeAnswerButton;
    });

    return {
      getDiv: () => div,
      getModeAnswerButtons: () => modeAnswerButtons
    }
  };

  const allModeAnswerButtons = [];
  const allModePlayButtons = [];

  const scaleUis = Array
      .from(new Array(scales.length).keys())
      .map((i) => ScaleUi(i, scales[i], scaleNames[i], scaleModeNames[i], i === 0));

  scaleUis.forEach((scaleUi) => appDiv.appendChild(scaleUi.getDiv()));

  const fretboardDiv = document.createElement('div');
  fretboardDiv.classList.add('hidden');

  appDiv.appendChild(fretboardDiv);

  const labelledRadioFormDivWidth = 100;

  const fretboard = FretboardBuilder()
      .medium()
      .ofNoOfFrets(15)
      .build();
  fretboard.setHorizontal();

  fretboardDiv.style['width'] = `${fretboard.getFretboardParentDivSize() + labelledRadioFormDivWidth}px`;
  fretboardDiv.style['height'] = `${fretboard.getFretboardParentDivSize()}px`;

  const labelledRadiosDiv = document.createElement('div');
  labelledRadiosDiv.appendChild(fretboard.getHandednessLabelledForm().getLabel());
  labelledRadiosDiv.appendChild(document.createElement('br'));
  labelledRadiosDiv.appendChild(fretboard.getOrientationLabelledForm().getLabel());
  labelledRadiosDiv.appendChild(document.createElement('br'));
  labelledRadiosDiv.style['position'] = 'absolute';
  labelledRadiosDiv.style['margin'] = '10px';
  labelledRadiosDiv.style['width'] = `${labelledRadioFormDivWidth}px`;
  labelledRadiosDiv.style['height'] = `${labelledRadioFormDivWidth}px`;
  fretboardDiv.appendChild(labelledRadiosDiv);
  const fretboardContainerDiv = document.createElement('div');
  fretboardContainerDiv.style['position'] = 'absolute';
  fretboardContainerDiv.style['left'] = `${labelledRadioFormDivWidth}px`;
  fretboardContainerDiv.appendChild(fretboard.getFretboardParentDiv());
  fretboardDiv.appendChild(fretboardContainerDiv);

});

</script>
</head>
<body>
<a style="margin: 10px; float: right;" href="https://www.github.com/kairuz/music-tools">GitHub</a>
<div id="app"></div>
</body>
</html>
